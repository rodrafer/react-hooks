# useEffect: persistent state

## 📝 Your Notes

Elaborate on your learnings here in `src/exercise/02.md`

You can make a performance improvement by using lazy initialization. If you pass to useState an initial value, it will be calculated on every render, but it will only be used on the first render (as an initial value for the state).

This is not a problem if you pass a simple value, a variable that's set to a simple value or calculation, or a function call to a function that performs a simple calculation. However, it's a problem when that varaible or function call (both of wich are calculated on every render) needs to perform an expensive calculation, like retrieving some data from localStorage.fgpl8u

In such cases (edge cases), it is better to define a function that performs such calculation, and pass the - reference to/definition of - that function as initializer. React useState will only execute that function on the first render (the only moment it needs it), in contrast with executing it on every render if a function call or variable is passed instead. This way, the only cost you pay is the definition of a function on every render, which is very cheap, in contrast to calling a costly function or calculating an expensive variable that in either case it will not be used after the first render.

However, do not define a function if the initial state is a primitive value. In such case it may be more expensive to define a function than to define a variable or calling a primitive.

Effects always run after a render, not before or along with it. They can be used to step out of React, to do something React has no defined way of doing, such as make HTTP requests, interact with browser APIs or initialize/close a server connection.

You can call useEffect without a dependency array. In such case, the effect will run on every re-render, even if that re-render was triggered by a parent component (it depends on everything as a matter of speech). If the effect only changes on state changes of the component its defined in, this lets you with effects running without need. To avoid this, specify the state to wich the effect should react in the effect dependency array. This way, only if that state or variable changes the effect will run.

Bear in mind that React useEffect makes a shallow comparison of the values in the dependency array (basically a '===' or Object.is), so if the dependency is an object, React will evaluate it as different from the previous value even if the object didn't change, which will make the effect run anyway.

Custom hooks are functions that uses another hooks. By convention, they shoud start with the 'use' prefix, though is not technically required for things to work.

You can set colors to console.log like so: console.log('%cApp: render start', 'color: MediumSpringGreen').

Effects cleanups run when the component is unmounted. Effects with an empty dependency array only run on the first render of the component, and its cleanup only when the component gets unmounted; none of which run on any re-render. On a re-render, cleanups of the corresponding effects (those without dependency array or with an updated dependency) will run, after which those same effects will re-run.

Renders are done following the component hierarchy: the parent component renders and re-renders before the child component. Besides, even if te parent returns a JSX with the child in it, React wont render the child until after it renders the parent. After that, effects and cleanups will run. On a re-render, the parent's cleanups will run before the child's effect do, and then the parent's effects are run. On child unmount, it's cleanups will run before those of the parent.

## Background

`React.useEffect` is a built-in hook that allows you to run some custom code
after React renders (and re-renders) your component to the DOM. It accepts a
callback function which React will call after the DOM has been updated:

```javascript
React.useEffect(() => {
  // your side-effect code here.
  // this is where you can make HTTP requests or interact with browser APIs.
})
```

Feel free to take a look at `src/examples/hook-flow.png` if you're interested in
the timing of when your functions are run. This will make more sense after
finishing the exercises/extra credit/instruction.

## Exercise

Production deploys:

- [Exercise](https://react-hooks.netlify.app/isolated/exercise/02.js)
- [Final](https://react-hooks.netlify.app/isolated/final/02.js)

In this exercise, we're going to enhance our `<Greeting />` component to get its
initial state value from localStorage (if available) and keep localStorage
updated as the `name` is updated.

## Extra Credit

### 1. 💯 lazy state initialization

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-1.js)

Right now, every time our component function is run, our function reads from
localStorage. This is problematic because it could be a performance bottleneck
(reading from localStorage can be slow). And what's more we only actually need
to know the value from localStorage the first time this component is rendered!
So the additional reads are wasted effort.

To avoid this problem, React's useState hook allows you to pass a function
instead of the actual value, and then it will only call that function to get the
state value when the component is rendered the first time. So you can go from
this: `React.useState(someExpensiveComputation())` To this:
`React.useState(() => someExpensiveComputation())`

And the `someExpensiveComputation` function will only be called when it's
needed!

Make the `React.useState` call use lazy initialization to avoid a performance
bottleneck of reading into localStorage on every render.

> Learn more about
> [lazy state initialization](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)

### 2. 💯 effect dependencies

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-2.js)

The callback we're passing to `React.useEffect` is called after _every_ render
of our component (including re-renders). This is exactly what we want because we
want to make sure that the `name` is saved into localStorage whenever it
changes, but there are various reasons a component can be re-rendered (for
example, when a parent component in the application tree gets re-rendered).

Really, we _only_ want localStorage to get updated when the `name` state
actually changes. It doesn't need to re-run any other time. Luckily for us,
`React.useEffect` allows you to pass a second argument called the "dependency
array" which signals to React that your effect callback function should be
called when (and only when) those dependencies change. So we can use this to
avoid doing unnecessary work!

Add a dependencies array for `React.useEffect` to avoid the callback being
called too frequently.

### 3. 💯 custom hook

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-3.js)

The best part of hooks is that if you find a bit of logic inside your component
function that you think would be useful elsewhere, you can put that in another
function and call it from the components that need it (just like regular
JavaScript). These functions you create are called "custom hooks".

Create a custom hook called `useLocalStorageState` for reusability of all this
logic.

### 4. 💯 flexible localStorage hook

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-4.js)

Take your custom `useLocalStorageState` hook and make it generic enough to
support any data type (remember, you have to serialize objects to strings... use
`JSON.stringify` and `JSON.parse`). Go wild with this!

## Notes

If you'd like to learn more about when different hooks are called and the order
in which they're called, then open up `src/examples/hook-flow.png` and
`src/examples/hook-flow.js`. Play around with that a bit and hopefully that will
help solidify this for you. Note that understanding this isn't absolutely
necessary for you to understand hooks, but it _will_ help you in some situations
so it's useful to understand.

> PLEASE NOTE: there was a subtle change in the order of cleanup functions
> getting called in React 17:
> <https://github.com/epicweb-dev/react-hooks/issues/90>

## 🦉 Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=02%3A%20useEffect%3A%20persistent%20state&em=).
