# Lifting state

## üìù Your Notes

Elaborate on your learnings here in `src/exercise/03.md`

- When you need to share state between sibling components so they can change/react together, you need to "lift the state up", which means removing individual states from the components and move it to their closest parent component. The paren will now be able to coordinate both components together, by passing the state down to it's children along with a mechanism for updating the state so they can use it as an event handler.

Optionally, you can pass hardcoded state values from the parent tho it's children to see how they react to different values, after you removed the state from the children and before you create the state on the parent. After creating the state on the parent, you could find a better state structure that better fits the components logic and functionality. The parent will now be the "single source of truth" of this particular state, and the children will react accordingly.

- A component with a local state is usually known as "uncontrolled", because it can manage its own state. When it's state is managed by props passed from some parent component rather than being defined inside of it, it is known as "controlled". This is because now it's parent fully controls it's behaviour.

Uncontrolled components are easier to use and need less configuration, but they lack flexibility when you want to coordinate them. Controlled components have total flexibility but they need more configuration.

"Controlled" and "uncontrolled" are not formal terms, and usualy components have a mix of local state and props, but they are useful to refer to the capabilities of each component when designing an app.

- If your state is way up your app, bear in mind that an update on the state will re-render every component under the component on wich the state is defined. If some of this components perform slow actions or renders, every other component will have to wait for it to re-render, leading to performance issues. In such cases, it may be better to "colocate" the state closer to the components, so a change on it wont trigger a re-render of many other components.

Global stores or contexts are a good example of this issue, and it mey be better to move some states like input changes closer to the actual input. The principle of colocation is "to keep state as close to where it is relevant as possible". If a component is the only one that needs that piece of state, locate it right there. If a sibling/relative component needs access to that state too, locate it on the closest common parent of both. If a lot of components among the app needs the state, locate it on a global store or context, but not every piece of state needs to be located there. This will benefit your app from a performance and maintenance perspective.

It is common to lift state up to make new features work, but it is not common to colocate state as the app grows to keep performance, because things will still working whether you colocate the state or not. This happend on the Extra Credit 01 for example, when the app changed so the Display component stopped needing access to the name state; things would have still worked if we leaved the name state on closest parent, but it could have lead to performance issues. The best to do here was to colocate the name state inside the Name component, wich was the only one needing it. So that is why you want to conciously think if you can colocate some state as your app grows/changes as a part of a maintenance cycle.

## Background

A common question from React beginners is how to share state between two sibling
components. The answer is to
["lift the state"](https://react.dev/learn/sharing-state-between-components)
which basically amounts to finding the lowest common parent shared between the
two components and placing the state management there, and then passing the
state and a mechanism for updating that state down into the components that need
it.

## Exercise

Production deploys:

- [Exercise](https://react-hooks.netlify.app/isolated/exercise/03.js)
- [Final](https://react-hooks.netlify.app/isolated/final/03.js)

üë®‚Äçüíº Peter told us we've got a new feature request for the `Display` component. He
wants us to display the `animal` the user selects. But that state is managed in
a "sibling" component, so we have to move that management to the lowest common
parent (`App`) and then pass it down.

## Extra Credit

### 1. üíØ colocating state

[Production deploy](https://react-hooks.netlify.app/isolated/final/03.extra-1.js)

As a community we‚Äôre pretty good at lifting state. It becomes natural over time.
One thing that we typically have trouble remembering to do is to push state back
down (or
[colocate state](https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster)).

üë®‚Äçüíº Peter told us that now users only want the animal displayed instead of the
name:

```javascript
function Display({animal}) {
  return <div>{`Your favorite animal is: ${animal}!`}</div>
}
```

You'll notice that just updating the `Display` component to this works fine, but
for the extra credit, go through the process of moving state to the components
that need it. You know what you just did for the `Animal` component? You need to
do the opposite thing for the `Name` component.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=03%3A%20Lifting%20state&em=).
